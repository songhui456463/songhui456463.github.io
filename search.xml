<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据结构链表学习</title>
    <url>/2021/10/07/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​        单链表中的每个结点不仅包含值，还包含链接到下一个结点的<code>引用字段</code>。通过这种方式，单链表将所有结点按顺序组织起来。</p>
<p>例子: </p>
<img src="/2021/10/07/%E9%93%BE%E8%A1%A8/1.png" style="zoom:50%;">



<h3 id="数据结构-java"><a href="#数据结构-java" class="headerlink" title="数据结构(java)"></a>数据结构(java)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Definition for singly-linked list.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SinglyListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    SinglyListNode next;</span><br><span class="line">    SinglyListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>​        与数组不同，我们无法在常量时间内访问单链表中的随机元素。 如果我们想要获得第 i 个元素，我们必须从头结点逐个遍历。 我们按索引来访问元素平均要花费 O(N) 时间，其中 N 是链表的长度。</p>
<p>​        例如，在上面的示例中，头结点是 23。访问第 3 个结点的唯一方法是使用头结点中的“next”字段到达第 2 个结点（结点 6）; 然后使用结点 6 的“next”字段，我们能够访问第 3 个结点。</p>
<h3 id="添加操作"><a href="#添加操作" class="headerlink" title="添加操作"></a>添加操作</h3><p>如果我们想在给定的结点 <code>prev</code> 之后添加新值，我们应该：</p>
<ol>
<li><p>使用给定值初始化新结点 <code>cur</code>；</p>
<img src="/2021/10/07/%E9%93%BE%E8%A1%A8/2.png" style="zoom:50%;">
</li>
<li><p>将 cur 的 next 字段链接到 prev 的下一个结点 next ；</p>
<img src="/2021/10/07/%E9%93%BE%E8%A1%A8/3.png" style="zoom:50%;">
</li>
<li><p>将 prev 中的 next 字段链接到 cur 。</p>
<img src="/2021/10/07/%E9%93%BE%E8%A1%A8/4.png" style="zoom:50%;">

<p>与数组不同，我们不需要将所有元素移动到插入元素之后。因此，您可以在 O(1) 时间复杂度中将新结点插入到链表中，这非常高效。</p>
</li>
</ol>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>如果我们想从单链表中删除现有结点 cur，可以分两步完成：</p>
<p>1.找到 cur 的上一个结点 prev 及其下一个结点 next ；</p>
<img src="/2021/10/07/%E9%93%BE%E8%A1%A8/5.png" style="zoom:50%;">

<p>2.接下来链接 prev 到 cur 的下一个节点 next 。</p>
<img src="/2021/10/07/%E9%93%BE%E8%A1%A8/6.png" style="zoom:50%;">

<p>在我们的第一步中，我们需要找出 prev 和 next。使用 cur 的参考字段很容易找出 next，但是，我们必须从头结点遍历链表，以找出 prev，它的平均时间是 O(N)，其中 N 是链表的长度。因此，删除结点的时间复杂度将是 O(N)。</p>
<p>空间复杂度为 O(1)，因为我们只需要常量空间来存储指针。</p>
<p>小技巧:</p>
<ol>
<li><p>将当前节点的后继节点值赋给当前节点，val = val-&gt;next，相当于把后继节点提前；</p>
</li>
<li><p>这时有两个重复的节点，然后index-&gt;next = index-&gt;next-&gt;next，相当于删除了后继节点。<br>总结来说，也就是把后继节点的值保留在当前节点上，然后删除后继节点，避免寻找前序节点的复杂操作。</p>
</li>
</ol>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p><a href="https://leetcode-cn.com/problems/design-linked-list/" target="_blank" rel="noopener">707. 设计链表</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针&#x2F;引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</span><br><span class="line">在链表类中实现这些功能：</span><br><span class="line">   get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</span><br><span class="line">   addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</span><br><span class="line">   addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</span><br><span class="line">   addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</span><br><span class="line">   deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * size可以不需要</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    MyLinkedList() &#123;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取链表中第 index 个节点的值。如果索引无效，则返回-1</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size || <span class="keyword">this</span>.head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(val);</span><br><span class="line">        node.next = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">this</span>.head = node;</span><br><span class="line">        <span class="keyword">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将值为 val 的节点追加到链表的最后一个元素</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(val);</span><br><span class="line">            <span class="keyword">this</span>.head.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node tail = <span class="keyword">new</span> Node(val);</span><br><span class="line">            tail.next = <span class="keyword">null</span>;</span><br><span class="line">            Node temp = <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.next = tail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在链表中的第 index 个节点之前添加值为 val的节点。</span></span><br><span class="line"><span class="comment">     * 如果 index 等于链表的长度，则该节点将附加到链表的末尾。</span></span><br><span class="line"><span class="comment">     * 如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="keyword">this</span>.size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            addAtHead(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="keyword">this</span>.size) &#123;</span><br><span class="line">            addAtTail(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node temp = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node insertNode = <span class="keyword">new</span> Node(val);</span><br><span class="line">        insertNode.next = temp.next;</span><br><span class="line">        temp.next = insertNode;</span><br><span class="line">        <span class="keyword">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果索引 index 有效，则删除链表中的第 index 个节点</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.size != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.head =<span class="keyword">this</span>.head.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.head = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.size--;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = temp.next.next;</span><br><span class="line">        <span class="keyword">this</span>.size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// MyLinkedList obj = new MyLinkedList();</span></span><br><span class="line">        <span class="comment">// int param_1 = obj.get(index);</span></span><br><span class="line">        <span class="comment">// obj.addAtHead(val);</span></span><br><span class="line">        <span class="comment">// obj.addAtTail(val);</span></span><br><span class="line">        <span class="comment">// obj.addAtIndex(index, val);</span></span><br><span class="line">        <span class="comment">// obj.deleteAtIndex(index);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><p>141.环形链表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表，判断链表中是否有环。</span><br><span class="line">如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</span><br><span class="line"> 如果链表中存在环，则返回 true 。 否则，返回 false 。</span><br></pre></td></tr></table></figure>

<p>我的代码:</p>
<p>思路: 从头结点开始遍历，用一个set集合去记录已经出现节点的hashcode，只要在当前遍历结点的下一节点不为空且当前节点的hashcode已在set集合中，则出现了环；若下一节点为空，则说明没有环；注意没有环的特殊情况，head为空时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution141</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; st = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        <span class="keyword">while</span> (!st.contains(temp.hashCode())) &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            st.add(temp.hashCode());</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官方第一种思路:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    Set&lt;ListNode&gt; st =<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    ListNode temp =head;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st.add(temp))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>杂度分析</strong></p>
<p>时间复杂度：O(N)O(N)，其中 NN 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。</p>
<p>空间复杂度：O(N)O(N)，其中 NN 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。</p>
<p><strong>优化思路(快慢指针)</strong></p>
<p>思路及算法</p>
<p>本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p>
<p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p>
<p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>
<p><strong>细节</strong></p>
<p>为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？</p>
<p>观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。</p>
<p>当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 快慢指针**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(N)O(N)，其中 NN 是链表中的节点数。</p>
<p>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。</p>
<p>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 NN 轮。</p>
<p>空间复杂度：O(1)O(1)。我们只使用了两个指针的额外空间。</p>
<h2 id="环形链表2"><a href="#环形链表2" class="headerlink" title="环形链表2"></a><strong>环形链表2</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</span><br><span class="line">为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</span><br><span class="line">说明：不允许修改给定的链表。</span><br></pre></td></tr></table></figure>

<p>思路:</p>
<p>还是快慢指针，只不过这次从相同点开始移动，当第一次相遇时，快指针比慢指针多走了n(S1+S2)，其中S1为入口点到相遇点的距离，S2位相遇点到入口点的距离，D为head到入口点的距离。</p>
<p>p1(慢指针) 走的距离:D+k(S1+S2)+S1;</p>
<p>p2(快指针)走的距离:D+(k+n)(S1+S2)+S1;</p>
<p>p2的速度为p1的两倍，时间一样，则路程为两倍:</p>
<p>​    2(D+k(S1+S2)+S1)=D+(k+n)(S1+S2)+S1</p>
<p>则D=(n-k-1)(S1+S2)+S2，D为slow从相遇点走(n-k-1)圈，再走S2到相遇点，言外之意，若快指针从head以1为速度，而慢指针以1位速度在第一次相遇点，则两指针必在入口点相遇。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="comment">// 第一次相遇</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有出口</span></span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fast从head开始以1位步长追slow,在圈进入点相遇</span></span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h2><p>​        给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p>
<p>如果两个链表相交，那么相交点之后的长度是相同的</p>
<p>我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这个位置只能是较短链表的头结点位置。<br>为此，我们必须消除两个链表的长度差</p>
<p>指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历<br>如果 pA 到了末尾，则 pA = headB 继续遍历<br>如果 pB 到了末尾，则 pB = headA 继续遍历<br>比较长的链表指针指向较短链表head时，长度差就消除了<br>如此，只需要将最短链表遍历两次即可找到位置。</p>
<img src="/2021/10/07/%E9%93%BE%E8%A1%A8/7.png" style="zoom:150%;">

<p>一般思路: 遍历headA链表，将已经遍历的链表节点放入set集合中，再遍历第二个链表，若contains方法放回true，则说明有相交节点，则返回，否则返回null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    Set&lt;ListNode&gt; st=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    ListNode temp = headA;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        st.add(temp);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp =headB;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.contains(temp))&#123;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化思路: 双指针pa和pb，两个指针分别从两个链表开始遍历，若任意一个指针为null，则将它指向另外一个节点，若在pa和pb指向同一个节点，则其为相交节点，并返回。特殊情况：其中一个头指针为空，则一定没有交点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode pa = headA,pb = headB;</span><br><span class="line">    <span class="keyword">while</span>(pa!=pb)&#123;</span><br><span class="line">        pa = pa == <span class="keyword">null</span>?headB:pa.next;</span><br><span class="line">        pb = pb == <span class="keyword">null</span>?headA:pb.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p>一般思路: 遍历链表，将节点放入栈中，再一个一个出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;ListNode&gt; st=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    ListNode temp = head;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        st.add(temp);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k==n)&#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode front = st.pop();</span><br><span class="line">        front.next =front.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化思路:双指针，快慢指针，先让快指针移动n个位置，后面快慢指针一起移动,当fast指针为空时，慢指针也就在删除节点前面一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 头结点</span></span><br><span class="line">    ListNode node = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">    <span class="comment">// 双指针，快慢指针，先让快指针移动n个位置，后面快慢指针一起移动</span></span><br><span class="line">    ListNode slow=node,fast=head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow.next = slow.next.next;</span><br><span class="line">    <span class="keyword">return</span> node.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习笔记</title>
    <url>/2021/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>仓库(Repository): 是用来存放项目代码的，每个项目对应一个代码。</p>
<p>收藏(Star): 收藏一些项目，方面下次查看。</p>
<p>复制克隆项目(Fork): 克隆项目，可以将别人的仓库完完整整复制一份到自己的仓库，并且该fork的项目是独立存在的。</p>
<p>发起请求(Pull): 因为fork的项目是 独立的，类似于拷贝，所以要想更改被fork的项目仓库，必须向其发起pull请求，请求通过后，仓库会合并。</p>
<p>关注(Watch)：如果你watch项目，当项目更新时可以接收到通知。</p>
<h2 id="Git基本信息设置"><a href="#Git基本信息设置" class="headerlink" title="Git基本信息设置"></a>Git基本信息设置</h2><ol>
<li>设置用户名</li>
</ol>
<p>​     git config –global user.name ‘用户名’</p>
<ol start="2">
<li>设置用户名邮箱</li>
</ol>
<p>​     git config –global user.email ‘xxxxxx@qq.com’</p>
<h2 id="git工作区"><a href="#git工作区" class="headerlink" title="git工作区"></a>git工作区</h2><p><img src="/2021/03/23/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/D:%5CBaiduNetdiskDownload%5Cblog-hexo%5Csource_posts%5Cgit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5Cgit_work.png" alt="git工作图"></p>
<p>git add ‘文件名’:  将文件存入暂存区</p>
<p>git commit -m ‘提交描述’:   将暂存区文件更新至本地仓库</p>
<p>git push：将本地仓库更新至与之关联的github远程仓库</p>
<p>git status： 可以让我们时刻掌握仓库当前的状态</p>
]]></content>
      <categories>
        <category>版本管理工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>博客说明(&lt;font color=&quot;red&quot;&gt;置顶&lt;/font&gt;)</title>
    <url>/2020/03/23/hello-world/</url>
    <content><![CDATA[<p>搭建这个博客主要是把这个当做一种笔记的形式进行记录，以便我可以在任何地方都可以查看我的笔记，并没有公开的打算，但是我今年我希望这里可以成为一个基础技术的学习之地。</p>
<h3 id="写博客的目的"><a href="#写博客的目的" class="headerlink" title="写博客的目的"></a>写博客的目的</h3><ul>
<li><p>其实这个站我已经建了一年多了，已经算是挺久的了，不过之前一直是当做笔记的作用</p>
</li>
<li><p>希望促进自己的进步，形成自己的知识体系，让自己了解过去的一年里做了什么</p>
</li>
<li><p>分享我的学习过程，认识有趣的人</p>
</li>
</ul>
<h3 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h3><ul>
<li>使用hexo搭建的博客，使用next主题</li>
<li>如果有什么建议或者意见，欢迎你向我提出，又或者有什么疑问，也欢迎你向我提问</li>
</ul>
<p><a href="http://wpa.qq.com/msgrd?v=3&uin=2430879746&site=qq&menu=yes" target="_blank" rel="noopener">点此联系我</a></p>
<h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
  </entry>
</search>
